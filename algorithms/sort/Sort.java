package sort;
/**
 * @Author ws
 * @Date 2021/3/20 15:15
 * @Version 1.0
 * <p>
 * 排序的稳定性: 相同的数的顺序在排完序后不改变   [1,4,6,4,8,4]
 * 三个4的先后顺序不改变
 * 意义:可以保留原始次序
 * 例:  201803523 王   1班
 * 201803524 李   2班
 * 201803525 张   1班
 * 按照学号结果如上
 * 现在再按班级排序
 * 201803523 王  1班
 * 201803525 张  1班
 * 201803524 李  2班
 * 此时王还在张的前面,保留了第一次排序的原始次序
 * <p>
 * 排序的稳定性: 相同的数的顺序在排完序后不改变   [1,4,6,4,8,4]
 * 三个4的先后顺序不改变
 * 意义:可以保留原始次序
 * 例:  201803523 王   1班
 * 201803524 李   2班
 * 201803525 张   1班
 * 按照学号结果如上
 * 现在再按班级排序
 * 201803523 王  1班
 * 201803525 张  1班
 * 201803524 李  2班
 * 此时王还在张的前面,保留了第一次排序的原始次序
 * <p>
 * 排序的稳定性: 相同的数的顺序在排完序后不改变   [1,4,6,4,8,4]
 * 三个4的先后顺序不改变
 * 意义:可以保留原始次序
 * 例:  201803523 王   1班
 * 201803524 李   2班
 * 201803525 张   1班
 * 按照学号结果如上
 * 现在再按班级排序
 * 201803523 王  1班
 * 201803525 张  1班
 * 201803524 李  2班
 * 此时王还在张的前面,保留了第一次排序的原始次序
 * <p>
 * 排序的稳定性: 相同的数的顺序在排完序后不改变   [1,4,6,4,8,4]
 * 三个4的先后顺序不改变
 * 意义:可以保留原始次序
 * 例:  201803523 王   1班
 * 201803524 李   2班
 * 201803525 张   1班
 * 按照学号结果如上
 * 现在再按班级排序
 * 201803523 王  1班
 * 201803525 张  1班
 * 201803524 李  2班
 * 此时王还在张的前面,保留了第一次排序的原始次序
 * <p>
 * 工程排序: 在大数组时:1.快速排序(当需要排序的数据是基本数据类型时,因为他不需要稳定,就算不稳定我们也看不出来)
 * 2.归并排序(当需要排序的数据是我们自定义的数据类型时,因为他需要稳定,就是上面所说的保留原始次序,如果不稳定我们可以看出来)
 * 在上面的两钟方法中的递归过程中,如果数据量小于60,直接用插入排序,因为在小数据量的时候插入排序的常数项更低更快
 * <p>
 * 排序的稳定性: 相同的数的顺序在排完序后不改变   [1,4,6,4,8,4]
 * 三个4的先后顺序不改变
 * 意义:可以保留原始次序
 * 例:  201803523 王   1班
 * 201803524 李   2班
 * 201803525 张   1班
 * 按照学号结果如上
 * 现在再按班级排序
 * 201803523 王  1班
 * 201803525 张  1班
 * 201803524 李  2班
 * 此时王还在张的前面,保留了第一次排序的原始次序
 * <p>
 * 排序的稳定性: 相同的数的顺序在排完序后不改变   [1,4,6,4,8,4]
 * 三个4的先后顺序不改变
 * 意义:可以保留原始次序
 * 例:  201803523 王   1班
 * 201803524 李   2班
 * 201803525 张   1班
 * 按照学号结果如上
 * 现在再按班级排序
 * 201803523 王  1班
 * 201803525 张  1班
 * 201803524 李  2班
 * 此时王还在张的前面,保留了第一次排序的原始次序
 * <p>
 * 排序的稳定性: 相同的数的顺序在排完序后不改变   [1,4,6,4,8,4]
 * 三个4的先后顺序不改变
 * 意义:可以保留原始次序
 * 例:  201803523 王   1班
 * 201803524 李   2班
 * 201803525 张   1班
 * 按照学号结果如上
 * 现在再按班级排序
 * 201803523 王  1班
 * 201803525 张  1班
 * 201803524 李  2班
 * 此时王还在张的前面,保留了第一次排序的原始次序
 * <p>
 * 排序的稳定性: 相同的数的顺序在排完序后不改变   [1,4,6,4,8,4]
 * 三个4的先后顺序不改变
 * 意义:可以保留原始次序
 * 例:  201803523 王   1班
 * 201803524 李   2班
 * 201803525 张   1班
 * 按照学号结果如上
 * 现在再按班级排序
 * 201803523 王  1班
 * 201803525 张  1班
 * 201803524 李  2班
 * 此时王还在张的前面,保留了第一次排序的原始次序
 * <p>
 * 工程排序: 在大数组时:1.快速排序(当需要排序的数据是基本数据类型时,因为他不需要稳定,就算不稳定我们也看不出来)
 * 2.归并排序(当需要排序的数据是我们自定义的数据类型时,因为他需要稳定,就是上面所说的保留原始次序,如果不稳定我们可以看出来)
 * 在上面的两钟方法中的递归过程中,如果数据量小于60,直接用插入排序,因为在小数据量的时候插入排序的常数项更低更快
 */


/**
 * 排序的稳定性: 相同的数的顺序在排完序后不改变   [1,4,6,4,8,4]
 * 三个4的先后顺序不改变
 * 意义:可以保留原始次序
 * 例:  201803523 王   1班
 * 201803524 李   2班
 * 201803525 张   1班
 * 按照学号结果如上
 * 现在再按班级排序
 * 201803523 王  1班
 * 201803525 张  1班
 * 201803524 李  2班
 * 此时王还在张的前面,保留了第一次排序的原始次序
 * <p>
 * 排序的稳定性: 相同的数的顺序在排完序后不改变   [1,4,6,4,8,4]
 * 三个4的先后顺序不改变
 * 意义:可以保留原始次序
 * 例:  201803523 王   1班
 * 201803524 李   2班
 * 201803525 张   1班
 * 按照学号结果如上
 * 现在再按班级排序
 * 201803523 王  1班
 * 201803525 张  1班
 * 201803524 李  2班
 * 此时王还在张的前面,保留了第一次排序的原始次序
 * <p>
 * 排序的稳定性: 相同的数的顺序在排完序后不改变   [1,4,6,4,8,4]
 * 三个4的先后顺序不改变
 * 意义:可以保留原始次序
 * 例:  201803523 王   1班
 * 201803524 李   2班
 * 201803525 张   1班
 * 按照学号结果如上
 * 现在再按班级排序
 * 201803523 王  1班
 * 201803525 张  1班
 * 201803524 李  2班
 * 此时王还在张的前面,保留了第一次排序的原始次序
 */


/**
 * 排序的稳定性: 相同的数的顺序在排完序后不改变   [1,4,6,4,8,4]
 * 三个4的先后顺序不改变
 * 意义:可以保留原始次序
 * 例:  201803523 王   1班
 *      201803524 李   2班
 *      201803525 张   1班
 *  按照学号结果如上
 *  现在再按班级排序
 *      201803523 王  1班
 *      201803525 张  1班
 *      201803524 李  2班
 *  此时王还在张的前面,保留了第一次排序的原始次序
 */


/**
 * 工程排序: 在大数组时:1.快速排序(当需要排序的数据是基本数据类型时,因为他不需要稳定,就算不稳定我们也看不出来)
 *                  2.归并排序(当需要排序的数据是我们自定义的数据类型时,因为他需要稳定,就是上面所说的保留原始次序,如果不稳定我们可以看出来)
 *          在上面的两钟方法中的递归过程中,如果数据量小于60,直接用插入排序,因为在小数据量的时候插入排序的常数项更低更快
 */


/**
 * 快排的改进,我们把等于key的部分,不参与后续的递归(三路快排)
 * T(N)=aT(N/b)+O(N^d)  即 T(N)=2T(N/2)+O(N^1) a=2,b=2,d=1
 * master公式:
 * log(b,a) > d   时间复杂度为:N^log(b,a)
 * log(b,a) ==d   时间复杂度为:N^d * logN   √
 * log(b,a) < d   时间复杂度为:N^d
 */

public class Sort {

    public static void main(String[] args) {

        int[] arr = {1, 4, -6, 8, 5, 7, 54, 10, 56, 12, -46, 231, 654, 2, 98, 4};
        BubbleSort.bubbleSort(arr);
        int[] arr2 = {1, 4, -6, 8, 5, 7, 54, 10, 56, 12, -46, 231, 654, 2, 98, 4};
        InsertSort.insertSort(arr2);
        int[] arr3 = {1, 4, -6, 8, 5, 7, 54, 10, 56, 12, -46, 231, 654, 2, 98, 4};
        QuickSort.quickMoreSort(arr3);
        int[] arr4 = {1, 4, -6, 8, 5, 7, 54, 10, 56, 12, -46, 231, 654, 2, 98, 4};
        ShellSort.shellSort(arr4);
        int[] arr5 = {1, 4, -6, 8, 5, 7, 54, 10, 56, 12, -46, 231, 654, 2, 98, 4};
        MergeSort.mergeSort(arr5);
        int[] arr5_1 = {1, 4, -6, 8, 5, 7, 54, 10, 56, 12, -46, 231, 654, 2, 98, 4};
        MergeSort.mergeSort2(arr5_1);
        int[] arr6 = {1, 4, 8, 5, 7, 54, 10, 56, 12, 231, 654, 2, 98, 4};
        BucketSort.countSort(arr6);
        int[] arr7 = {1, 4, 6, 8, 5, 7, 54, 10, 56, 12, 46, 231, 654, 2, 98, 4};
        RadixSort.radixSort(arr7);

        int[] arr8 = {1, 4, -6, 8, 5, 7, 54, 10, 4};
        QuickSort.quickMoreSort(arr8);

        int[] arr9 = {1, 4, -6, 8, 5, 7, 54, 10, 4};
        HeapSort.heapSort(arr9);


    }
}
